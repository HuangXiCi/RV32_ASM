## Function call and back



一般情况下，指令是顺序执行的，更新的PC值是原值+4，但在遇到**转移分支指令**的时候，需要根据转移情况更新为跳转位置的地址值

在高级语言如C语言中，还会调用一些函数，并在调用完成后返回继续顺序执行接下来的语句，如下:

```c
#include<stdio.h>
int pow(int a,int b);
int main()
{
    int a, b;
    scanf("%d %d",&a,&b);
    printf("%d",pow(a,b));
    return 0;
}
int pow(int a,int b)
{
    int c=1,i;
    for(i=0;i<b;i++)
    {
        c*=a;
    }
    return c;
}
```

**我们把函数调用分为六个步骤:**

1. 发生函数调用时，在执行函数功能前，先将这次调用中需要用到的参数保存，方便取用
2. 将控制权移交给这次调用的功能函数
3. 根据情况为函数申请一定的本地存储空间，以满足函数执行过程中需要的存储需求
4. 执行该函数的功能操作
5. 在函数执行完成后，将得到的结果数据存放好，便于主进程来获取，同时还原函数执行过程中使用到的寄存器值，释放分配给函数的本地存储空间
6. 将控制权转移给原进程

在RISC-V中将a0-a7(编号为x10-x17的寄存器)用来向调用的函数传递参数，a0和a1寄存器常用于传递返回值

ra，即x1寄存器，用来保存返回时的返回地址值

s0-s11，对应编号x8-x9和x18-x27的寄存器用来作为保存寄存器，保存原进程中的关键数据，避免在函数调用的过程中被破坏

**在RISC-V中，所有指令都是4字节的**

以下为函数调用的实例:

C code:

```c
......	sum(a,b);	......
    
int sum(int x ,int y)
{
    return x+y;
}
```

in ASM:

```assembly
address		instruction
1000		add a0, s0, x0
1004		add a1, s1, x0
1008		addi ra, x0, 1016
1012		j	sum
1016		......
2000		sum:	add a0, a0, a1
2004		jr	ra
```

- **jr**

jr指令能跳转到寄存器值所对应的地址空间，我们使用这条指令跳转到ra寄存器保存的地址值以实现函数的返回

在汇编用法中，可以用ret指令来指代jr ra的操作

- **jal(jump and link)**

通过jal指令，可以形成指向调用点的地址或链接，从而使函数能返回正确的地址

跳转则会使PC跳转指向被调用函数的地址

并且将链接得到的下一指令的地址作为返回地址，保存在ra寄存器中
